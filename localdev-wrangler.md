# Local Development with Cloudflare D1 & Next.js (OpenNext)

This guide documents the configuration required to successfully run a Next.js application with Cloudflare D1 locally using `next dev`, bypassing the limitations of standard bindings in the local environment.

## The Challenge

When running `next dev`, the application runs in a standard Node.js environment, not the Cloudflare Workers runtime. This means:

1.  **Missing Bindings**: `env.DB` (the D1 binding) is not automatically available.
2.  **Runtime Mismatch**: D1 is an async API, while local SQLite solutions (like `better-sqlite3`) are synchronous.
3.  **Native Modules**: `better-sqlite3` is a native Node.js module that requires compilation and specific build configuration.

## 1. Configuration Files

### `wrangler.jsonc`

For Cloudflare Pages local development to recognize the correct database, you must specify `preview_database_id`.

```jsonc
{
  "d1_databases": [
    {
      "binding": "DB",
      "database_name": "your-db-name",
      "database_id": "your-prod-id",
      "preview_database_id": "DB" // <--- REQUIRED for local dev
    }
  ]
}
```

### `package.json`

You must explicitly allow `better-sqlite3` to run its build script, otherwise `pnpm` will block it for security, causing "binding not found" errors.

```json
{
  "pnpm": {
    "onlyBuiltDependencies": ["better-sqlite3", "esbuild", "sharp"]
  },
  "scripts": {
    "db:generate": "drizzle-kit generate",
    "db:migrate:local": "wrangler d1 migrations apply DB --local",
    "db:migrate:prod": "wrangler d1 migrations apply DB --remote"
  }
}
```

### `next.config.ts`

Since `better-sqlite3` is a native module, it cannot be bundled by Webpack. It must be marked as external.

```typescript
const nextConfig: NextConfig = {
  experimental: {
    serverComponentsExternalPackages: ["better-sqlite3"],
  },
};
```

## 2. The Database Connection Helper (`src/lib/db.ts`)

To support both production (Edge/D1) and development (Node/SQLite), we use a robust fallback strategy:

1.  **Attempt Cloudflare Context**: Try to get `env.DB` from `@opennextjs/cloudflare`.
2.  **Fallback to Local SQLite**: If `env.DB` is missing (typical in `next dev`), locate the local SQLite file generated by Wrangler.
3.  **Proxy for Compatibility**: Use `drizzle-orm/sqlite-proxy` to wrap the synchronous `better-sqlite3` instance, making it behave like the asynchronous D1 API. This prevents type errors and runtime crashes.

```typescript
// Simplified logic
if (process.env.NODE_ENV === "development") {
  // 1. Find the .sqlite file in .wrangler/state/v3/d1/miniflare-D1DatabaseObject
  // 2. Connect with new Database(path)
  // 3. Wrap with drizzleProxy(async (sql, params, method) => { ... })
}
```

## 3. API Route Configuration

Native modules like `better-sqlite3` **only** work in the Node.js runtime. However, Cloudflare Workers require the Edge runtime. We use conditional exports to satisfy both:

```typescript
// src/app/api/your-route/route.ts
export const runtime = process.env.NODE_ENV === "development" ? "nodejs" : "edge";
```

## 4. Setup Checklist for New Environments

To recreate this environment elsewhere:

1.  **Install Dependencies**:

    ```bash
    pnpm install
    # Ensure build scripts run! If better-sqlite3 fails, run: pnpm rebuild better-sqlite3
    ```

2.  **Generate Local Database**:

    ```bash
    # This creates the .sqlite file in .wrangler/state
    pnpm db:migrate:local
    ```

3.  **Start Development**:
    ```bash
    pnpm dev
    ```

## Troubleshooting

- **"Database binding not found"**: Run `pnpm rebuild better-sqlite3`. Check `package.json` `onlyBuiltDependencies`.
- **"env.DB is undefined"**: Ensure `wrangler.jsonc` has `preview_database_id`.
- **Type Errors**: Ensure you are casting the `db` instance if TypeScript complains about the union type of `D1Database | BetterSQLite3Database`.
